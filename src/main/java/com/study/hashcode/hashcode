    有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时
是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。

1.因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？
    肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，
但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。
如果要判断两个对象是否真正相等，必须通过equals方法。

    结论：
        也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；
        如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；
        如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；
        如果两个对象的hashcode值相等，则equals方法得到的结果未知。



2.为什么引进hashcode方法：
                       对于集合的操作大家都比较熟了，CRUD，但是基于**散列的集合**操作,要求上就高了一点，
就是我们不允许有重复的对象出现在这些散列集合中。那么我们怎么控制不能有相同的对象出现在这些散列集合中呐，我们
可能会首先想到equrals方法，没错，这个方法可以。但是我们操作的数据量大到一定程度，比如说是10万条数据时我们可
能会发现要用equrals比较很多次，方能得出我们想要的答案。 我们可以怎么来优化这个过程呐，其实很简单就是把equrals
比较的次数减少不就行了，但是怎么减少呐，答案就是hashcode，这里我们要说明一点，hashcode不可以比较出两个对象是
否相等，但是它可以比较出两个对象是否不等，因为两个对象可能会产生相同的hashcode，但是hashcode不同的一定是两
个对象。 实际上hashmap的具体实现中会有一个专门的table表来保存这个容器中对象的所有的hashcode值，当你用map
存数据时，它会首先判断这个hashcode值是否在这个table表上，如果不在，数据直接存进去，如果在，再去比较数据的值
是否一样，如果一样就不存了，如果不一样就去存。 put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，
会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法
重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法
的存在是为了减少equals方法的调用次数，从而提高程序效率。 我在说一下，关于对象在重写equrals时要不要重写hashcode，
答案是要的，因为hashcode将对象的存储地址进行了映射。如果不写就会报null