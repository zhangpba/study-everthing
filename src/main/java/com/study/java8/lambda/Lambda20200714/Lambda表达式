一 引子：

    java8之前，我们可以写成：

        new Thread(new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("thread");
                    }
                });

    通过lambda表达式，可以写成：

        new Thread(() -> System.out.println("thread"));

    针对这种实行，我们怎么理解呢？其实很简单，
    上看一下上述lambda表达式的语法：() -> {}(): 括号就是接口方法的括号，接口方法如果有参数，也需要写参数。
    只有一个参数时，括号可以省略。-> : 分割左右部分的，没啥好讲的。{} : 要实现的方法体。
    只有一行代码时，可以不加括号，可以不写return。

    不过看到这里我相信有些小伙伴已经许意识到了，如果接口中有多个方法时，那么按照上面的逻辑lambda表达式恐怕没办法表示了。
    的确是这样，并非任何接口都支持lambda表达式。

二 函数式接口： 所谓的函数式接口，当然首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。
              这种类型的接口也称为SAM接口，即Single Abstract Method interfaces。

    1.1 函数式接口的基本语法
        他们主要用在Lambda表达式和方法引用(实际上也可认为是Lambda表达式)上。如定义了一个函数式接口:GreetingService

        那么就可以使用Lambda表达式来表示改接口的一个实现(java8之前一般使用匿名类实现的)

    1.2 FunctionalInterface注解
        关于@FunctionalInterface注解java8为函数式接口引入了一个新注解，主要用于编译级错误检查，
        加上该注解，当你写的接口不符合函数式接口定义的时候，编译会报错

    1.3 用法提示
        error:接口中包含了两个抽象方法，违反了函数式接口的定义，IDE会直接报错。
        Tips:加不加@FunctionalInterface对于接口是不是函数式接口没有影响，该注解只是提醒编译器去检查该接口是否仅包含i月个抽象方法

    1.4 默认方法
        函数式接口里面是可以包含默认方法，因为默认方法不是抽象方法，其有一个默认实现，所以是符合函数式接口的定义的。

    1.5 静态方法
        函数式接口里是可以包含静态方法，因为静态方法不能是抽象方法，是一个已经实现了的方法，所以是符合函数式接口的定义的。

    1.6 Object里的public方法
        函数式接口里是可以包含Object里的public方法，这些方法对于函数式接口来说，不被当成抽象函数方法(虽然他们是抽象的)；
        以为任何一个函数式接口的实现，默认都继承了Object类，包含了来自java.lang.Object里对这些抽象方法的实现

三 进阶
    有了上面的基础，我们稍稍聊一些深入的lambda表达式。lambda表达式还有两种简化代码的手段，它们是方法引用、构造引用。

    方法引用是什么呢？如果我们要实现接口的方法与另一个方法A类似，（这里的类似是指参数类型与返回值部分相同），
    我们直接声明A方法即可。也就是，不再使用lambda表达式的标准形式，改用高级形式。无论是标准形式还是高级形式，
    都是lambda表达式的一种表现形式。

    方法引用的语法：
    对象::实例方法类::静态方法类::实例方法
    前两个很容易理解，相当于对象调用实例方法，类调用静态方法一样。只是第三个需要特殊说明。
        Compare<Boolean> c = String::equals;
    也就是“类::实例方法”的形式。


四 构造引用










*参考文档：https://baijiahao.baidu.com/s?id=1614680282522143196&wfr=spider&for=pc